# プログラミングモデル

プログラミングモデル「Kokkos」は、以下の6つのコア抽象化によって特徴づけられます: 実行空間,
実行パターン、実行ポリシー、メモリ空間、メモリレイアウト、およびメモリ特性。 これらの抽象化概念により、汎用的なアルゴリズムやデータ構造を構築することが可能となり、それらを様々な種類のアーキテクチャに適用することが可能となります。 実質的に、これらはアルゴリズムのコンパイル時変換を可能にし、ハードウェアの並列性の程度やメモリ階層構造に応じて適応させることを可能にします。

![abstractions](figures/kokkos-abstractions-doc.png)

<h4>図 3.1  プログラミングモデルのコア抽象化　</h4>

## 実行空間

実行空間とは、コードが実際に実行される場所 _Where_ を指します。 例えば、現在のハイブリッド　GPU/CPU　システムでは、実行スペースとして2種類が存在します：　GPU　コアおよび　CPU　コアです。 将来的には、メモリ内処理（PIM）モジュールや、ヘテロジニアス　CPU　上の異なるコアタイプなどが含まれる可能性があります。 原則として、これはリモートメモリ空間の導入にも利用可能です。例えば、異なるノードへ作業を送信する機能などが挙げられます。 実行空間は、アプリケーション開発者が異種混在ハードウェアアーキテクチャの異なる部分をターゲットとする手段を提供します。 これは、以前に説明した機械モデルに直接対応しております。

## 実行パターン

実行パターンは、その中でアプリケーションが表現されなければならない、 _基本的パラレルアルゴリズム_ です。　例は、以下の通りです。 

* [`parallel_for()`](../API/core/parallel-dispatch/parallel_for): 関数を指定された回数だけ、順序を定めずに実行、
* [`parallel_reduce()`](../API/core/parallel-dispatch/parallel_reduce): `parallel_for()`の実行および還元演算の組合せ、
* [`parallel_scan()`](../API/core/parallel-dispatch/parallel_scan): 各演算の出力値について、parallel_for()　演算と接頭辞または接尾辞スキャンを組み合わせ、および
* `task`: 他の関数への依存関係を持つ、単関数を実行。

アプリケーションをこれらのパターンで表現することで、基盤となる実装および使用されるコンパイラが有効な変換について、推論することが可能となります。例えば、すべての `parallel_***` パターンは、実行順序を設定せず、還元処理自体の結果のみが確定的であることを、保証します。これにより、異なるハードウェア上で、例えば、反復処理のスレッドおよびベクトルレーンの割り当てといった、異なるマッピングパターンが可能となります。 

## 実行ポリシー

実行ポリシーは、実行パターンと組み合わせて、関数が _どのように_　実行されるかを決定します。一部のポリシーは、他のポリシー内にネストすることが可能です。 

### 範囲ポリシー

実行ポリシーの中で、もっとも単純な形態は、 _範囲ポリシー_　です。それらは、範囲内の各要素に対して一度ずつ演算を実行するために使用されます。 There are no prescriptions of order of execution or concurrency, which means that it is not legal to synchronize different iterations.

### チームポリシー

チームポリシーは、階層的並列性を実装するために使用されます。 そのために、Kokkos　は、スレッドを　 _teams_　にグループ化します。 _thread team_ とは、1つ以上の並列な実行　"スレッド"　の集合体です。 Kokkos では、任意の数のチームの作成 - the _league size_　が可能です。 ハードウェアの制約により、チーム内のスレッド数 - the _team size_　は制限されます。 チーム内のすべてのスレッドは、確実に同時に実行されます

チーム内のスレッドは同期が可能です。これらは "barrier" プリミティブを備えており、一時的な保存に使用できる　"スクラッチパッド"　メモリを共有します。 Kokkos　ではすべての同期メカニズムが有効とは限らないことに注意してください。特に、チーム内のスレッドに対して、"スピンロック"　を実装すると、デッドロックが発生する可能性があります。 Kokkos　では、スレッドの順序保証は提供されておりません。つまり、チーム内の別のスレッドが取得したロックで待機状態にある単一のスレッドが、コンピューティングエンジンのリソースを、100%使用してしまう可能性があります。 明示的な Kokkos を、 _チームバリア_　と呼ぶことが、チーム内のスレッドを同期させるための唯一の安全な方法です。

スクラッチパッドメモリは、並列演算中のみ存在します; その内部の割り当てはカーネル間で持続しません。 チーム自体は任意の順序で実行され、必ずしも全てが並行して実行されるとは限りません。　例えば、ユーザーが  _T_ チームを要求する場合、 ハードウェアは、それらを順番に順次実行するか、あるいは最大 _G_ チーム単位のグループで、同時に並列実行することを選択できます。

ユーザーは、並列演算を　 _ネスト_ することができます。チームは、1つの並列操作（for、reduce、またはscan）を実行することができ、各チーム内のスレッドは別の、場合によっては異なる並列演算を実行できます。異なるチームは、全く異なることを行う場合があります。 例えば、あるチーム内のすべてのスレッドが、For example, all the threads in one team may execute a [`parallel_for()`](../API/core/parallel-dispatch/parallel_for) を実行し、異なるチーム内のすべてのスレッドが、 [`parallel_scan()`](../API/core/parallel-dispatch/parallel_scan)　を実行する場合があります。 チーム内の異なるスレッドは、それぞれ異なる処理を行う場合があります。ただし、チーム内のスレッドが動作において　"分岐"　した場合（例えば、ブランチの異なる側を選択した場合など）、パフォーマンスにばらつきが生じる可能性があります。 [Chapter 8 - Hierarchical Parallelism](HierarchicalParallelism) は、C++　実装における Kokkos のスレッドチーム公開方法について、説明しています。

NVIDIA　の　CUDA　プログラミングモデルは、Kokkos　のスレッドチームモデルに影響を与えました。 スクラッチパッドメモリは、CUDAのチームごとの　"共有メモリ"　に対応しています。 "リーグ／チーム"　という用語は、OpenMP 4.0に由来するもので、当社のスレッドチームモデルと多くの共通点があります。 このモデルに向けたプログラミングは、完全なモデルの一部のみを実装するコンピュータアーキテクチャにおいても、良好な性能を発揮することが確認されております。 例えば、高性能コンピューティングで一般的に使用されているマルチコアプロセッサの多くは、"スクラッチパッド"　ハードウェアを備えておりません。 ただし、ユーザーがチーム内のスレッド間で共有される最大のキャッシュに収まるサイズのスクレイチパッドを要求した場合、スクレイチパッドが存在するかのようにプログラミングすることで、ユーザーはアルゴリズムにおいて局所性を考慮せざるを得なくなります。 これはまた、より制約の多いハードウェア向けにコードを書き直した後、そのコードを通常のハードウェアに　_逆_　移植することで、最適化されていないコードと比較してパフォーマンスが向上する傾向にあるという、一般的な経験則を反映しています。

## メモリ空間

メモリ空間とは、データが存在する場所　_Where_ です。 データの物理的な位置と、特定のアクセス特性を指定します。データの物理的な位置と特定のアクセス特性を指定します。 異なる物理的な場所には、高帯域幅メモリ、オンダイスクラッチメモリ、あるいは不揮発性バルクストレージといったものが対応します。  which is accessible from Host and GPU. 異なる論理メモリ空間により、CUDAプログラミングモデルにおける　UVM　メモリのような概念が可能となりますが、これはホストとGPUの両方からアクセスできます。将来的には、メモリ空間を用いてリモートメモリ位置を表現することも可能となるでしょう。 さらに、それらは整合性制御および永続性スコープといった機能を、カプセル化しております

## メモリレイアウト

レイアウトは、データ配置における論理的（またはアルゴリズム的）インデックスからアドレスオフセットへの _マッピング_ を表現します。 メモリ構造に適したレイアウトを採用することにより、アプリケーションは特定のアルゴリズムにおけるデータアクセスパターンを最適化することが可能です。 実装が多態的レイアウト（すなわち、データ構造がコンパイル時または実行時に異なるレイアウトでインスタンス化可能であること）を提供する場合には、アーキテクチャ依存の最適化を行うことが可能です。

## メモリ特性

メモリ特性とは、アルゴリズムにおいて 　_データ構造にどのようにアクセスするか_　を規定するものです。 特性は、アトミックアクセス、ランダムアクセス、ストリーム形式の読み込みまたは保存、といった使用シナリオを表現します。 データ構造にそのような属性を付与することで、 プログラミングモデルの実装では、最適な読み込みおよび保存演算を挿入することが可能です。コンパイラが、プログラミングモデルを実装している場合、アクセスモードについて推論を行い、それをコード変換の指針とすることが可能です。
